Esse arquivo relato o processo de aprendizado durante a escrita das soluções. 

;;; EX03
    Há dois arquivos para esse problema e o motivo disso é que o primeiro ficou muito bagunçado, declarando todas as funções diretamente nele e contendo muitos comentários. Esse primeiro não funcionou. Através do GDB eu vi que tudo ocorre bem até o momento de ler os dados do resultado. Não consegui entender bem o que estava acontecendo de errado ali.

    Na segunda tentativa eu decidi refazer o código do zero e separar as funções que transformam o texto em número e o número em texto em arquivos diferentes.
    Pelo gdb, confirmei que a primeira função está funcionando bem, mas após adicionar a segunda e tentar executar o código, recebo um erro de segmentation fault.
    Esse erro parece ser na etapa de ler o resultado. Vou debugar novamente e tentar entender qual é o erro.

    -- debug
    Coloquei os inputs 30 e 23, e estou vendo que o código transformou essas sequências de bytes para números corretamente e os somou com sucesso. O valor 53 está em rax;
    A função num_string entra fica presa em um loop infinito. Quando eu faço test rax, rax, na sequência, eu incremento o r8d. Talvez algo altere a flag zero nesse meio tempo, porque o jnz continua pulando para o início do loop. 
        Vou inverter o inc r8d e o test rax, rax de lugar.
        Deu certo! Não sei o motivo ainda, mas funcionou. Olhei o endereço e agora sim eu vejo os caracteres no endereço onde n3 está armazenado. 
        Algo estranho acontece em seguida. Eu vejo que rcx (que deveria guardar a quantidade de iterações da função anterior), mas o valor nele é muito grande, provavelmente um endereço. Isso explica o segmentation fault...
        Deu certo! O problema, dessa vez realmente era a operação em r8d antes do jump.

        Após resolver o problema eu vi no livro "x86-64 Assembly programming language with Ubuntu, Ed Jorgensen" que a CPU atualiza o registrador rFlag a cada instrução, e isso justifica o problema.

;;; EX04
    Além de debug, vou usar esse arquivo para fazer comentários.
    Na tabela ASCII vemos que os digitos estão entre 48 e 57;
    Letras estão entre 65 e 122 (de 91 até 96, não há letras)

    A estratégia vai ser bem simples. Vou percorrer fazer dois testes, um para verificar a existência de algarismos e outro, para a existência de letras;
    Temos as seguintes preposições:
    N1: x >=48
    N2: x <= 57
    N1 and N2 = é numérico = N

    A1: x >= 65
    A2: x <= 90
    A3: x >= 97
    A4: x <= 122
    (A1 and A2) or (A3 and A4) = é alfabético = A

    A and N = AN = é alfanumerico

    Acabou que eu fiz algo nem mais improvisado e não segui o que está aqui. O problema foi bem mais suave que o anterior, mas ainda tive um problema. 
    Eu havia entendido errado o comportamento de test. No GDB, percebi que o programa estava funcionando perfeitamente, exceto pelo detalhe da flag ZF estar sempre ativa após o test al, bl. Isso acontece porque test x, y sempre ativa ZF, exceto quando x e y são ambos diferentes de zero.

;;; EX05    

    As funções que transformam cadeia de caracteres em números e vice-versa já foram escritas, mas como o objetivo é praticar e como elas me deram certa dor de cabeça, vamos reimplementar sem olhar as funções do ex03.
    
;;; EX06 
    Tá funcionando mais ou menos. Ele responde o que deve, mas printa um 4 e dá um erro de segmentation fault no final.
    Todos os exercícios foram 100% autorais, mas os 2 e 3 eu precisei de dicas e o 4 eu pedi revisões, mas todo o código e ideias usadas no ex04 foram originais.
    O ex05 é o primeiro que faço completamente sem usar nenhum tipo de ajuda externa, consegui ir digitando do início ao fim sem nem pedir revisão e consertei o problema analisando a depuração. Então esse exercício é um ponto interessante nesse miniprojeto de aprendizado do básico de assembly. 